---
// FallingLogos.astro - WebGL GPU-accelerated falling logos with PNG texture and rainbow trails
---

<canvas id="falling-logos-canvas"></canvas>

<style>
  #falling-logos-canvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    pointer-events: none;
    z-index: 9998;
    opacity: 0;
    transition: opacity 0.3s ease;
  }
  
  #falling-logos-canvas.active {
    opacity: 1;
  }
</style>

<script>
  import logoTexture from '../assets/FRIENDS_Icon_Blk_v002.png';

  const canvas = document.getElementById('falling-logos-canvas') as HTMLCanvasElement;
  const gl = canvas.getContext('webgl2', { 
    alpha: true, 
    antialias: true,
    powerPreference: 'high-performance'
  });

  if (!gl) {
    console.warn('WebGL2 not supported');
  }

  // Brand colors in ROYGBV order
  const COLORS = [
    [0.941, 0.224, 0.161], // Red #F03929
    [1.0, 0.573, 0.0],     // Orange #FF9200
    [0.890, 0.965, 0.031], // Yellow #E3F608
    [0.008, 0.780, 0.475], // Green #02C779
    [0.047, 0.290, 0.898], // Blue #0C4AE5
    [0.333, 0.133, 0.659], // Purple #5522A8
  ];

  // Vertex shader with instancing and texture coordinates
  const vertexShaderSource = `#version 300 es
    precision highp float;
    
    in vec2 a_position;
    in vec2 a_texCoord;
    in vec3 a_instancePosition;  // x, y, alpha
    in vec3 a_instanceColor;
    in float a_instanceScale;
    
    uniform vec2 u_resolution;
    uniform float u_logoAspect;
    
    out vec2 v_texCoord;
    out vec3 v_color;
    out float v_alpha;
    
    void main() {
      // Apply instance transformations
      vec2 pos = a_position * a_instanceScale;
      pos.x *= u_logoAspect;
      
      // Translate to instance position
      pos += a_instancePosition.xy;
      
      // Convert to clip space
      vec2 clipSpace = (pos / u_resolution) * 2.0 - 1.0;
      clipSpace.y *= -1.0;
      
      gl_Position = vec4(clipSpace, 0.0, 1.0);
      
      v_texCoord = a_texCoord;
      v_color = a_instanceColor;
      v_alpha = a_instancePosition.z; // alpha stored in z
    }
  `;

  // Fragment shader with texture sampling and color tinting
  const fragmentShaderSource = `#version 300 es
    precision highp float;
    
    in vec2 v_texCoord;
    in vec3 v_color;
    in float v_alpha;
    
    uniform sampler2D u_texture;
    
    out vec4 outColor;
    
    void main() {
      vec4 texColor = texture(u_texture, v_texCoord);
      
      // Use texture alpha, tint with color
      // If pixel is black in texture, apply color tint
      float luminance = dot(texColor.rgb, vec3(0.299, 0.587, 0.114));
      vec3 finalColor = mix(v_color, texColor.rgb, luminance);
      
      outColor = vec4(finalColor, texColor.a * v_alpha);
    }
  `;

  // Compile shader
  function createShader(type: number, source: string) {
    if (!gl) return null;
    const shader = gl.createShader(type);
    if (!shader) return null;
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      console.error('Shader compile error:', gl.getShaderInfoLog(shader));
      gl.deleteShader(shader);
      return null;
    }
    return shader;
  }

  // Create program
  function createProgram(vertexShader: WebGLShader, fragmentShader: WebGLShader) {
    if (!gl) return null;
    const program = gl.createProgram();
    if (!program) return null;
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      console.error('Program link error:', gl.getProgramInfoLog(program));
      gl.deleteProgram(program);
      return null;
    }
    return program;
  }

  // Setup WebGL
  const vertexShader = createShader(gl.VERTEX_SHADER, vertexShaderSource);
  const fragmentShader = createShader(gl.FRAGMENT_SHADER, fragmentShaderSource);
  
  if (!vertexShader || !fragmentShader) {
    console.error('Failed to create shaders');
  }

  const program = vertexShader && fragmentShader ? createProgram(vertexShader, fragmentShader) : null;

  if (!program) {
    console.error('Failed to create WebGL program');
  }

  // Get attribute and uniform locations
  const positionLoc = gl.getAttribLocation(program!, 'a_position');
  const texCoordLoc = gl.getAttribLocation(program!, 'a_texCoord');
  const instancePositionLoc = gl.getAttribLocation(program!, 'a_instancePosition');
  const instanceColorLoc = gl.getAttribLocation(program!, 'a_instanceColor');
  const instanceScaleLoc = gl.getAttribLocation(program!, 'a_instanceScale');
  const resolutionLoc = gl.getUniformLocation(program!, 'u_resolution');
  const logoAspectLoc = gl.getUniformLocation(program!, 'u_logoAspect');
  const textureLoc = gl.getUniformLocation(program!, 'u_texture');

  // Create quad vertices (2 triangles)
  const QUAD_VERTICES = new Float32Array([
    // Position  // TexCoord
    0.0, 0.0,    0.0, 0.0,
    0.0, 1.0,    0.0, 1.0,
    1.0, 1.0,    1.0, 1.0,
    
    1.0, 1.0,    1.0, 1.0,
    1.0, 0.0,    1.0, 0.0,
    0.0, 0.0,    0.0, 0.0,
  ]);

  // Create vertex buffer
  const vertexBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, QUAD_VERTICES, gl.STATIC_DRAW);

  // Create instance buffers
  const instancePositionBuffer = gl.createBuffer();
  const instanceColorBuffer = gl.createBuffer();
  const instanceScaleBuffer = gl.createBuffer();

  // Load texture
  const texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  
  // Set temporary 1x1 white pixel while loading
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([255, 255, 255, 255]));
  
  const textureImage = new Image();
  textureImage.onload = () => {
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImage);
    gl.generateMipmap(gl.TEXTURE_2D);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  };
  textureImage.src = logoTexture.src;

  // VAO
  const vao = gl.createVertexArray();
  gl.bindVertexArray(vao);

  // Setup vertex attributes
  gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
  
  // Position attribute
  gl.enableVertexAttribArray(positionLoc);
  gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 16, 0);
  
  // TexCoord attribute
  gl.enableVertexAttribArray(texCoordLoc);
  gl.vertexAttribPointer(texCoordLoc, 2, gl.FLOAT, false, 16, 8);

  // Setup instance attributes
  gl.bindBuffer(gl.ARRAY_BUFFER, instancePositionBuffer);
  gl.enableVertexAttribArray(instancePositionLoc);
  gl.vertexAttribPointer(instancePositionLoc, 3, gl.FLOAT, false, 0, 0);
  gl.vertexAttribDivisor(instancePositionLoc, 1);

  gl.bindBuffer(gl.ARRAY_BUFFER, instanceColorBuffer);
  gl.enableVertexAttribArray(instanceColorLoc);
  gl.vertexAttribPointer(instanceColorLoc, 3, gl.FLOAT, false, 0, 0);
  gl.vertexAttribDivisor(instanceColorLoc, 1);

  gl.bindBuffer(gl.ARRAY_BUFFER, instanceScaleBuffer);
  gl.enableVertexAttribArray(instanceScaleLoc);
  gl.vertexAttribPointer(instanceScaleLoc, 1, gl.FLOAT, false, 0, 0);
  gl.vertexAttribDivisor(instanceScaleLoc, 1);

  // Physics constants - user's preferred settings
  const GRAVITY = 0.5;
  const BOUNCE_DAMPING = 0.8;
  const LOGO_SCALE = 240;
  const LOGO_ASPECT = 269 / 358;
  const TRAIL_LENGTH = 40;
  const MAX_LOGOS = 8;
  
  // Frame rate limiting for classic Solitaire look
  const TARGET_FPS = 120; // Lock to 30fps
  const FRAME_TIME = 1000 / TARGET_FPS;
  let lastFrameTime = 0;

  // Logo class
  class FallingLogo {
    x: number;
    y: number;
    vx: number;
    vy: number;
    bounces: number;
    maxBounces: number;
    trail: Array<{ x: number; y: number; alpha: number }>;
    dead: boolean;

    constructor(x: number, y = -150) {
      this.x = x;
      this.y = y;
      this.vx = (Math.random() - 0.5) * 8;
      this.vy = 0;
      this.bounces = 0;
      this.maxBounces = 4;
      this.trail = [];
      this.dead = false;
    }

    update(canvasHeight: number, canvasWidth: number) {
      this.vy += GRAVITY;
      this.y += this.vy;
      this.x += this.vx;

      // Add trail
      this.trail.push({ x: this.x, y: this.y, alpha: 1.0 });
      if (this.trail.length > TRAIL_LENGTH) {
        this.trail.shift();
      }

      // Fade trail
      this.trail.forEach((t, i) => {
        t.alpha = (i + 1) / this.trail.length;
      });

      // Floor collision
      const floorY = canvasHeight - LOGO_SCALE;
      if (this.y >= floorY && this.vy > 0 && this.bounces < this.maxBounces) {
        this.y = floorY;
        this.vy = -this.vy * BOUNCE_DAMPING;
        this.bounces++;
      }

      // Accelerate after max bounces
      if (this.bounces >= this.maxBounces) {
        this.vy = Math.max(this.vy, 5);
      }

      // Mark dead when off screen
      if (this.y > canvasHeight + 100) {
        this.dead = true;
      }

      // Wall bounce
      if (this.x <= 0 || this.x + LOGO_SCALE * LOGO_ASPECT >= canvasWidth) {
        this.vx = -this.vx;
        this.x = Math.max(0, Math.min(this.x, canvasWidth - LOGO_SCALE * LOGO_ASPECT));
      }
    }

    getInstances() {
      const instances: Array<{
        x: number;
        y: number;
        alpha: number;
        color: number[];
        scale: number;
      }> = [];
      
      // Add trail with rainbow gradient
      this.trail.forEach((t, i) => {
        const progress = i / Math.max(1, this.trail.length - 1);
        const colorIndex = Math.floor(progress * (COLORS.length - 1));
        const nextColorIndex = Math.min(colorIndex + 1, COLORS.length - 1);
        const factor = (progress * (COLORS.length - 1)) - colorIndex;
        
        // Interpolate color
        const color = COLORS[colorIndex].map((c, j) => 
          c + (COLORS[nextColorIndex][j] - c) * factor
        );
        
        instances.push({
          x: t.x,
          y: t.y,
          alpha: t.alpha * 0.6,
          color: color,
          scale: LOGO_SCALE
        });
      });
      
      // Add main logo (black)
      instances.push({
        x: this.x,
        y: this.y,
        alpha: 1.0,
        color: [0, 0, 0],
        scale: LOGO_SCALE
      });
      
      return instances;
    }
  }

  // Animation state
  let logos: FallingLogo[] = [];
  let isRunning = false;
  let spawnInterval: number;
  let animationId: number;

  // Resize handler
  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    gl.viewport(0, 0, canvas.width, canvas.height);
  }
  resize();
  window.addEventListener('resize', resize);

  // Render function with frame rate limiting
  function render(currentTime: number) {
    if (!isRunning) return;

    // Frame rate limiting
    const deltaTime = currentTime - lastFrameTime;
    if (deltaTime < FRAME_TIME) {
      animationId = requestAnimationFrame(render);
      return;
    }
    lastFrameTime = currentTime - (deltaTime % FRAME_TIME);

    // Update logos
    logos.forEach(logo => logo.update(canvas.height, canvas.width));
    logos = logos.filter(logo => !logo.dead);

    // Collect all instances
    const allInstances = logos.flatMap(logo => logo.getInstances());

    // Clear canvas
    gl.clearColor(0, 0, 0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT);

    if (allInstances.length > 0) {
      // Prepare instance data
      const positions = new Float32Array(allInstances.length * 3);
      const colors = new Float32Array(allInstances.length * 3);
      const scales = new Float32Array(allInstances.length);

      allInstances.forEach((inst, i) => {
        positions[i * 3] = inst.x;
        positions[i * 3 + 1] = inst.y;
        positions[i * 3 + 2] = inst.alpha;

        colors[i * 3] = inst.color[0];
        colors[i * 3 + 1] = inst.color[1];
        colors[i * 3 + 2] = inst.color[2];

        scales[i] = inst.scale;
      });

      // Upload instance data
      gl.bindBuffer(gl.ARRAY_BUFFER, instancePositionBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, positions, gl.DYNAMIC_DRAW);

      gl.bindBuffer(gl.ARRAY_BUFFER, instanceColorBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, colors, gl.DYNAMIC_DRAW);

      gl.bindBuffer(gl.ARRAY_BUFFER, instanceScaleBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, scales, gl.DYNAMIC_DRAW);

      // Draw
      gl.useProgram(program);
      gl.bindVertexArray(vao);
      
      gl.enable(gl.BLEND);
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

      gl.uniform2f(resolutionLoc, canvas.width, canvas.height);
      gl.uniform1f(logoAspectLoc, LOGO_ASPECT);
      
      // Bind texture
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.uniform1i(textureLoc, 0);

      gl.drawArraysInstanced(gl.TRIANGLES, 0, 6, allInstances.length);
    }

    animationId = requestAnimationFrame(render);
  }

  // Spawn logo
  function spawnLogo() {
    if (logos.length >= MAX_LOGOS) return;
    const x = Math.random() * (canvas.width - LOGO_SCALE * LOGO_ASPECT);
    logos.push(new FallingLogo(x));
  }

  // Public API for starting/stopping
  (window as any).startFallingLogos = () => {
    if (isRunning) return;
    canvas.classList.add('active');
    logos = [];
    isRunning = true;
    lastFrameTime = performance.now();
    spawnInterval = setInterval(spawnLogo, 1400) as unknown as number;
    spawnLogo();
    animationId = requestAnimationFrame(render);
  };

  (window as any).stopFallingLogos = () => {
    canvas.classList.remove('active');
    isRunning = false;
    if (spawnInterval) clearInterval(spawnInterval);
    if (animationId) cancelAnimationFrame(animationId);
    logos = [];
    gl.clearColor(0, 0, 0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT);
  };
</script>