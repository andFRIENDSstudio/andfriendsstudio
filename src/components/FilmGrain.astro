---
// FilmGrain.astro - GPU-accelerated animated film grain
---

<canvas id="film-grain"></canvas>

<style>
  #film-grain {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    pointer-events: none;
    z-index:-1; /* Below cursor (9999) but above everything else */
    opacity: 0.03; /* More visible now with proper grain */
  }

  @media (max-width: 768px) {
    #film-grain {
      opacity: 0.02; /* Lighter on mobile to save battery */
    }
  }
</style>

<script>
  const canvas = document.getElementById('film-grain') as HTMLCanvasElement;
  const gl = canvas.getContext('webgl', { 
    alpha: true,
    antialias: false,
    depth: false,
    stencil: false,
    premultipliedAlpha: true,
    preserveDrawingBuffer: false,
    powerPreference: 'low-power' // Battery friendly
  });

  if (!gl) {
    console.warn('WebGL not supported, grain disabled');
  } else {
    // Vertex shader - just a fullscreen quad
    const vertexShader = gl.createShader(gl.VERTEX_SHADER)!;
    gl.shaderSource(vertexShader, `
      attribute vec2 position;
      void main() {
        gl_Position = vec4(position, 0.0, 1.0);
      }
    `);
    gl.compileShader(vertexShader);

    // Fragment shader - film grain with time-based animation
    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER)!;
    gl.shaderSource(fragmentShader, `
      precision highp float;
      uniform vec2 resolution;
      uniform float time;
      
      // High-quality noise function with better distribution
      float hash(vec3 p) {
        p = fract(p * 0.3183099 + 0.1);
        p *= 17.0;
        return fract(p.x * p.y * p.z * (p.x + p.y + p.z));
      }
      
      // 3D noise for smooth grain
      float noise(vec3 x) {
        vec3 i = floor(x);
        vec3 f = fract(x);
        f = f * f * (3.0 - 2.0 * f);
        
        return mix(
          mix(
            mix(hash(i + vec3(0,0,0)), hash(i + vec3(1,0,0)), f.x),
            mix(hash(i + vec3(0,1,0)), hash(i + vec3(1,1,0)), f.x),
            f.y
          ),
          mix(
            mix(hash(i + vec3(0,0,1)), hash(i + vec3(1,0,1)), f.x),
            mix(hash(i + vec3(0,1,1)), hash(i + vec3(1,1,1)), f.x),
            f.y
          ),
          f.z
        );
      }
      
      void main() {
        vec2 uv = gl_FragCoord.xy / resolution.xy;
        
        // Create animated grain with 3D noise (time as Z axis)
        float grain = 0.0;
        
        // Multiple octaves for organic texture - FASTER animation speeds
        grain += noise(vec3(uv * 800.0, time * 16.0)) * 0.5;
        grain += noise(vec3(uv * 1600.0, time * 24.0)) * 0.25;
        grain += noise(vec3(uv * 3200.0, time * 12.0)) * 0.125;
        
        // Normalize to 0-1 range
        grain = grain / 0.875;
        
        // Add slight contrast boost
        grain = grain * 1.2 - 0.1;
        
        gl_FragColor = vec4(vec3(grain), 1.0);
      }
    `);
    gl.compileShader(fragmentShader);

    // Link program
    const program = gl.createProgram()!;
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    gl.useProgram(program);

    // Setup fullscreen quad
    const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
    const buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

    const position = gl.getAttribLocation(program, 'position');
    gl.enableVertexAttribArray(position);
    gl.vertexAttribPointer(position, 2, gl.FLOAT, false, 0, 0);

    // Get uniform locations
    const resolutionLocation = gl.getUniformLocation(program, 'resolution');
    const timeLocation = gl.getUniformLocation(program, 'time');

    // Resize handler
    const resize = () => {
      const dpr = Math.min(window.devicePixelRatio, 2); // Cap at 2x for performance
      canvas.width = window.innerWidth * dpr;
      canvas.height = window.innerHeight * dpr;
      gl.viewport(0, 0, canvas.width, canvas.height);
      gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
    };
    
    resize();
    window.addEventListener('resize', resize);

    // Animation loop
    let startTime = Date.now();
    let animationId: number;
    let isActive = true;

    const render = () => {
      if (!isActive) return;
      
      const time = (Date.now() - startTime) * 0.001; // Convert to seconds
      gl.uniform1f(timeLocation, time);
      
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      
      animationId = requestAnimationFrame(render);
    };

    render();

    // Pause when tab inactive (battery optimization)
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        isActive = false;
        cancelAnimationFrame(animationId);
      } else {
        isActive = true;
        startTime = Date.now(); // Reset time to avoid jumps
        render();
      }
    });
  }
</script>